\documentclass[11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{cfr-lm}
\usepackage[australian,american]{babel}

%\usepackage[font=footnotesize]{subcaption}

%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage[headsepline,footsepline,automark]{scrlayer-scrpage}
\usepackage{minted}
%\usepackage{tabu}
%\usepackage{longtable}
\usepackage{multirow}
\usepackage{setspace}
%\usepackage{graphicx}
%\usepackage{pgfplots}
\usepackage{url}
\usepackage{titling}
%\usepackage[backend=biber,style=ieee,bibencoding=utf8,sorting=none]{biblatex}
\usepackage{csquotes}
\usepackage{pdfpages}
%\usepackage[nomarkers,figuresonly]{endfloat}
\usepackage{siunitx}
%\usepackage{epstopdf}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{todonotes}
\usepackage{pdflscape}
\usepackage[hidelinks]{hyperref}

%\usepackage{enumitem}

%\pgfplotsset{width=12cm,height=6cm,compat=1.11}

% Constants
\def\mytitle{Distributed Hash Tables}
\def\myauthor{Sébastien Vaucher}

\pagestyle{scrheadings}

\ihead{\headmark}
\chead{}
\ohead{\myauthor}
\cfoot{}
\ifoot{Large-Scale Distributed Systems, Assignment 2}
\ofoot{\thepage}

\posttitle{\end{center}\begin{center}\LARGE Large-Scale Distributed Systems\end{center}}

\author{\myauthor\\ \href{mailto:sebastien.vaucher@unine.ch}{sebastien.vaucher@unine.ch}}
\title{\huge \textbf{\mytitle}}

\hypersetup{
	pdftitle=\mytitle,
	pdfauthor=\myauthor
}

%\renewcommand{\efloatseparator}{\mbox{}}

\begin{document}

\nocite{*}

\begin{titlingpage}

\begin{otherlanguage}{australian}
\maketitle
\end{otherlanguage}

%\setcounter{tocdepth}{1}
\tableofcontents
%\listoffigures

\begin{table}[b]
\centering
\subfloat{\includegraphics[height=1.3cm]{jmcs.png}}
\qquad\qquad
\subfloat{\includegraphics[height=1.5cm]{unine.pdf}}
\end{table}

\end{titlingpage}

\pagebreak

\section{Introduction}

This report presents the results obtained in the second assignment of the Large-Scale Distributed Systems course taught at the University of Neuchâtel. The goal of the assignment is the implement a distributed hash table using the Chord algorithm. The implementation is done in the Lua programming language, using the Splay framework.

Apart from this report, a number of files are supplied:

\begin{description}
\item[dht.lua]\hfill\\ Contains the implementation of the fault-tolerant DHT.
\item[dht-noft.lua]\hfill\\ Contains the implementation of the DHT without fault-tolerance.
\item[dht.sh]\hfill\\ Bash script to launch the program on a local machine.
\item[*.txt]\hfill\\ Raw logs generated by the program running on the cluster of the university.
\item[parse\_stale.pl]\hfill\\ Perl script to generate the number of stale nodes over time.
\item[parse\_task-34.pl]\hfill\\ Perl script to generate the number of failed queries over time.
\item[*.gp]\hfill\\ Gnuplot scripts generating the graphs found in this report.
\item[generate\_graphs.sh] Script to generate the plots found in this report from the raw logs.
\end{description}

All the data presented in this report is the result of executions on the Splay cluster of the university.

\section{Search performance}

\begin{figure}
	\centering
	\includegraphics[width=0.96\linewidth]{task-22.pdf}
	\caption{Distribution of the number of hops for random queries, with and without a finger table}
	\label{fig:22}
\end{figure}

The goal of a Distributed Hash Table is to store various objects under certain keys.
The responsibility for each key is defined by the identifier of a node and its position on the ring.
To assess the search performance of our DHT, we queried the ring 500 times per node.
We then recorded the number of nodes that had been traversed to reach the node responsible for each key.

\autoref{fig:22} shows the number of hops that has been traversed on the abscissa.
The ordinate is the number of occurrences for a particular hop-count.
The lowest the hop-count the better.
Therefore, the more \enquote{left-aligned} the distribution, the better.

\subsection{Without a finger table}

The first implementation of our DHT only used a single pointer towards the successor on the ring.
Its performance is represented with red bars on \autoref{fig:22}.
In this configuration, a given key can be found by sending a query around the ring until the responsible node is receives the query.
The traversal of the ring is unidirectional, therefore the hop-count for a query is bounded by $\left[0,RingSize-1\right]$, where $RingSize$ is the number of nodes in the DHT.
$0$ indicates that the node sending the query is already the responsible node (the best-case scenario), $RingSize-1$ is the worst case: all the nodes have been traversed until the responsible node gets found.

From the plot, we can conclude that the distribution of hop-counts is uniform in this configuration.
The performance is therefore abysmal.
In a DHT with more nodes, this implementation would be unusable.

\subsection{With a finger table}

The second implementation adds a so-called finger table to each node.
A finger table is a map from a key to a node.
Each node stored in it serves as a shortcut to a certain range of keys.
We can therefore reach responsible nodes in less hops.

In \autoref{fig:22}, the green bars show the improved performance brought with the introduction of the finger table.
The worst case is now as low as 6 hops, versus 63 without this optimization.

\section{Fault-tolerant DHT}

In a realistic setup, nodes are able to join or leave the DHT at any time.
The Splay framework has a feature to simulate this behavior: churn traces.
A churn trace is a file listing start times and end times for each node.
At each start time, a node tries to join the DHT, while at an end time a node suddenly dies.

In the perspective of a well-functioning node, a pointer towards a dead node is still valid (i.e not \textsf{nil}).
Finger table entries that are not \textsf{nil} but point to a dead node are called stale entries.
\autoref{fig:stale} shows the number of stale entries over time when churn happens.
We can see that the rise in stale pointers is concurrent with the death of some nodes.
At approximately $t=\SI{500}{s}$, the ring reaches a state of no return where all tested fingers point to dead nodes.

The rise in stale entries can be attributed to two causes.
The first is obvious and is the sudden death of a node.
The second has to do with the conditions we use to qualify an entry as fresh or stale.
A finger entry is considered as stale if it is not \textsf{nil} and if the referenced node does not reply to a \textsf{rpc.ping} request.
As nodes die, the \textsf{fig_fingers} procedure will gradually sanitize finger entries either by setting to a active node, or to \textsf{nil} when a failure happens.

\begin{figure}
	\centering
	\includegraphics[width=0.96\linewidth]{stale.pdf}
	\caption{Percentage of stale entries in the finger table under churn}
	\label{fig:stale}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{task-34-hops.pdf}
	\caption{Distribution of the number of hops for random queries under churn}
	\label{fig:34-hops}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.96\linewidth]{task-34-successes.pdf}
	\caption{Evolution of the hop-count and percentage of failed queries under churn}
	\label{fig:34-successes}
\end{figure}

\end{document}