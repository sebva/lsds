\documentclass[11pt,a4paper,parskip=half]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[rm={oldstyle=false}]{cfr-lm}
\usepackage[australian,american]{babel}

\usepackage[headsepline,footsepline,automark]{scrlayer-scrpage}
\usepackage{minted}
\usepackage[super]{nth}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{url}
\usepackage{titling}
\usepackage[minnames=1,maxnames=3,backend=biber,style=ieee, bibencoding=utf8,sorting=none]{biblatex}
\usepackage{csquotes}
\usepackage{pdfpages}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{todonotes}
\usepackage{pdflscape}
\usepackage[hidelinks]{hyperref}

% Constants
\def\mytitle{Chord-on-Demand}
\def\myauthor{Sébastien Vaucher}

\pagestyle{scrheadings}

\ihead{\headmark}
\chead{}
\ohead{\myauthor}
\cfoot{}
\ifoot{Large-Scale Distributed Systems, Assignment 3}
\ofoot{Page \thepage}

\posttitle{\end{center}\begin{center}\LARGE Large-Scale Distributed Systems\end{center}}

\author{\myauthor\\ \href{mailto:sebastien.vaucher@unine.ch}{sebastien.vaucher@unine.ch}}
\title{\huge \textbf{\mytitle}}

\hypersetup{
	pdftitle=\mytitle,
	pdfauthor=\myauthor
}

\addbibresource{references.bib}

\begin{document}

\begin{titlingpage}

\begin{otherlanguage}{australian}
\maketitle
\end{otherlanguage}

\tableofcontents

\begin{table}[b]
\centering
\subfloat{\includegraphics[height=1.3cm]{jmcs.png}}
\qquad\qquad
\subfloat{\includegraphics[height=1.5cm]{unine.pdf}}
\end{table}

\end{titlingpage}

\pagebreak

\section{Introduction}

This report presents the results obtained in the third and last assignment of the Large-Scale Distributed Systems course taught at the University of Neuchâtel.
The goal of the assignment is the implement the Chord-on-Demand \autocite{cod} algorithm, also known as \textit{T-Chord}.
Chord-on-Demand uses T-Man \autocite{tman} to emerge a Chord \autocite{chord} structure from the random graph provided by a peer-sampling service.
The implementation is done in the Lua programming language, using the Splay framework.

Apart from this report, a number of files are supplied:

\begin{description}
\item[chord-on-demand.lua]\hfill\\ Implementation of the Chord-on-Demand algorithm (Chord \& T-Man).
\item[pss.lua]\hfill\\ Implementation of a peer-sampling service carried over from the first assignment.
\item[chord-on-demand.sh]\hfill\\ Bash script to launch the program on a local machine.
\item[*.txt]\hfill\\ Raw logs generated by the program running on the cluster of the university.
\item[*.gp]\hfill\\ Gnuplot scripts generating the graphs found in this report.
\item[parse\_tman.pl]\hfill\\ Log parser in Perl that computes the average distance between nodes in T-Man view throughout the execution.
\item[parse\_bootstrap.py]\hfill\\ Log parser in Python that computes the number of nodes having the correct Chord successor at each T-Man iteration.
\item[generate\_graphs.sh]\hfill\\ Script to generate the plots found in this report from the raw logs. Some plot data is directly generated by this script, while other are delegated to Perl and Python scripts.
\end{description}

All the data presented in this report is the result of executions on the Splay cluster of the university.
For this assignment, we were given more liberties regarding what we wanted to do.
The workplan that was agreed for this project was as follows:

\begin{enumerate}
\item\label{work:tman} Implement the T-Man algorithm
\item\label{work:bootstrap} Integrate Chord jump-starting using T-Man
\item\label{work:fingers} Add fingers management (bootstrapped from T-Man)
\item\label{work:failure} Implement and test failure-resilience:
\begin{enumerate}
\item\label{work:ksuccs} Have a list of $k$ successors as backup for each node
\item\label{work:fallback} When a successor node fails, replace it with its successor
\item\label{work:ping} Implement maintenance of the Chord ring by regularly testing for nodes aliveness
\end{enumerate}
\end{enumerate}

Tasks \ref{work:tman} through \ref{work:fingers} were successfully realized and tested.
Task \ref{work:failure} was only partially implemented.
Only sub-task \ref{work:ksuccs} was implemented.

\section{Algorithm}

The goal of Chord-on-Demand is to \textit{bootstrap} a Chord structure from a random graph.
The algorithm is described in \autocite{cod}, but a summary is provided in this section.
Adaptations to the algorithms described in the paper needed to be made; they are listed in this section.

The T-Chord algorithm proceeds by iterations.
At each iteration, each node will exchange its current view, a random subset from its peer-sampling service, along with information about itself.
When a node contacts another, it sends these nodes metadata.
The passive node will also exchange the same type of information.
The exchange is therefore bi-directional.

Whenever a node receives information about peers from another node, it will combine them with already known information residing in its local view.
The resulting aggregation will be sanitized, to remove doubloons and copies of the local node.
A sorting function is applied to the sanitized list.
This function defines how to organize the emerged structure.
In our case the nodes are sorted in ascending order of distance (using the identifier from Chord) to the local node.
After $n$ iterations, the converged list of nodes contains the nodes that are closer to the local node, i.e. immediate predecessors and successors in the DHT.

To this procedure, we added a step that guarantees that the immediate successor of the local node is always kept, otherwise there is a probability that the algorithm would never manage to bootstrap a valid DHT structure.

When a fixed number of iterations have been performed, we start bootstrapping the Chord structure from the T-Man view.
What happens is that we sort the T-Man view by Chord ID in ascending order.
The node that is immediately before the current node becomes its predecessor in the Chord ring.
The node that immediately follows the current node becomes its successor.
To increase the reliability of Chord, we add all the nodes that follow the current node, and are located in the following half of the ring space, as backup successors.

The algorithm as described above, while creating a fully-functional Chord DHT, performs miserably.
The Chord algorithm mandates the addition of a finger-table that provides shortcuts across the ring, leading to smaller hop-counts for individual queries.
These fingers can be discovered using the T-Man algorithm.
Our implementation can be schematized as $m$ individual instances of T-Man, each with a view size of 1.
$m$ is the size of the finger-table, which is linked to the number of bits in the identifier of Chord.
Of course, we did not ran $28+1$ instances of T-Man in parallel.
What we did was integrate the finger selection logic in the existing T-Chord pipeline.
This way, there is no network overhead.

\section{Analysis of the results}

\subsection{Convergence of T-Man}

\begin{figure}
\centering
\includegraphics[scale=1]{tman_convergence.pdf}
\caption{Evolution of the average distance between nodes across T-Man iterations}
\label{fig:tman_convergence}
\end{figure}

We tested our implementation against a group of 64 nodes.
In \autoref{fig:tman_convergence}, we show how the average distance between nodes evolves.
We see that the T-Man algorithm correctly manages to rapidly feed each node with a view containing nodes that are close.
With lower view sizes, the average distance between nodes is smaller.
This does not indicate better performance, but is a side-effect of the reduced neighbors per node.
With less neighbors, a node only chooses the closest nodes and discards distant nodes.
This leads to a smaller average distance between nodes.

\subsection{Convergence towards a correct DHT}

\begin{figure}
\centering
\includegraphics[scale=1]{bootstrap_convergence.pdf}
\caption{Bootstrapping performance across T-Man iterations}
\label{fig:boostrap_convergence}
\end{figure}

Our specific usage of T-Man is T-Chord.
To generate \autoref{fig:boostrap_convergence}, we tried to bootstrap a Chord DHT after each T-Man iteration.
In the Y axis, we display the number of nodes in our system that managed to bootstrap Chord using the correct successor.
A result of 64 indicates that the perfect ring was discovered.

The size of T-Man's view has a clear influence on the time it takes to convergence towards the DHT structure.
With reasonable values (view size of 6 and up), we can see that the perfect result can be reached in 11 iterations.
More importantly, we see that, for all view sizes, the slope of the curve is never negative.
This proves that our implementation is working as intended.

The number of cycles we measure is quite high in comparison with results from \autocite{cod}.
In this paper, the authors needed $<8$ cycles for a network of $2^{10}$ nodes.
In our result, we see that the algorithm convergences rapidly to more than 60 correct successors, but then stagnates and takes some more cycles just for the last incorrect nodes.

\subsection{Bootstrapping the fingers}

\begin{figure}
\centering
\includegraphics[scale=1]{query_distribution.pdf}
\caption{Distribution of hop-counts with and without fingers}
\label{fig:fingers}
\end{figure}

To analyze whether our finger bootstrapping mechanism works as expected, we let the T-Chord algorithm run for 20 iterations.
After these iterations, we performed random queries on the DHT and collected the number of hops needed to reach the responsible node.

In \autoref{fig:fingers}, there are 3 different results plotted.
The blue bars show the case with no finger table.
As expected, the distribution is flat, denoting very poor performance.
The results using red bars are brought over from the previous assignment on classical Chord.
Finally, the result that uses fingers bootstrapped from T-Man is shown in green.

We can see that the fingers discovered from T-Man provide sensibly the same result than fingers discovered using the mechanisms from traditional Chord.
This highlights that our implementation is totally functional.
Combining the discovery of the finger-table within the existing T-Chord pipeline is in fact a valid approach.

\subsection{Multiple successors}

Our implementation of T-Chord bootstraps at least one node as successor.
In cases where it is possible, our implementation of the algorithm will bootstrap successive successors as backups.

In a fault-tolerant implementation of Chord, these backup successors would take place of a failed successor to permit the continuation of operations under churn.
Each node should periodically check if its successor is alive.
When a failure is detected, the node will replace it with the failed node's own successor.
This resiliency mechanism was not implemented for this assignment, mainly due to a lack of time (it was in the workplan as tasks \ref{work:fallback} and \ref{work:ping}).

\section{Conclusion}

The goal of the T-Chord algorithm is to create a DHT from a group of nodes.
We have successfully implemented the necessary components that allow to transition from a random graph to an organized DHT meeting Chord's specifications.
Our implementation is able to converge to a correct DHT in a handful of cycles.

We made some modifications to the algorithm proposed in \autocite{cod}.
Instead of choosing finger nodes from the final view, we integrated the finger-bootstrapping procedure in the existing T-Man pipeline, in the \textsf{select\_view} function\footnote{Known as $\text{merge}\left(message, view\right)$ in \autocite{cod}.}.
This method does not incur additional costs in terms of network usage, and proved to discover fingers that performed as great as those discovered using the complete finger discovery mechanism used in the non-fault-resilient variant of the Chord protocol.

We were able to reuse pieces of code written for the two previous assignments with only minor modifications to them.
The peer-sampling service and the implementation of Chord were brought over in this fashion.
This assignment can therefore be considered as a successful mashup of different distributed systems techniques.

The foundations to render the Chord protocol fault-resilient are in place.
Each node is bootstrapped with multiple successors, and the implementation of Chord is able to use the \textsf{fix\_fingers} and \textsf{stabilize} mechanisms.
Some more work would be needed to integrate fallback procedures into the regular query methods.
An additional step would be to periodically check for the consistency of the ring, and transition to a backup successor if appropriate.

\begin{otherlanguage}{australian}
\printbibliography
\end{otherlanguage}

\end{document}
